## Computer Architecture

### 3장 명령어  

### 3-02 명령어의 구조  
- **연산코드와 오퍼랜드**
  - 명령어는 __'무엇을 대상으로, 어떤 작동을 수행하라'__ 라는 구조  
  - 명령어는 연산코드(operation code)와 오퍼랜드(operand)로 구성
  <br>

  - **연산코드(operation code)**
    - 명령어가 수행할 연산(연산자)
    - 연산코드가 담기는 영역 operation code field
    - 연산코드의 종류는 다양하지만 가장 기본적인 연산 코드 유형은 아래의 네가지로 나뉨
      - 데이터 전송
        > **MOVE**: 데이터를 옮겨라  
        > **STORE**: 메모리에 저장하라  
        > **LOAD(FETCH)**: 메모리에서 CPU로 데이터를 가져와라  
        > **PUSH**: 스택에 데이터를 저장하라  
        > **POP**: 스택의 최상단 데이터를 가져와라  
        <br>
      - 산술/논리 연산
        > **ADD / SUBSTRACT / MULTIPLY / DIVIDE** : 덧셈/뺄셈/곱셈/나눗셈 수행하라  
        > **INCREMENT / DECREMENT**: 오퍼랜드에 1을 더하라 / 오퍼랜드에 1을 빼라  
        > **AND / OR / NOT**: AND/OR/NOT 연산을 수행  
        > **COMPARE**: 두 개의 숫자 또는 TRUE/FALSE 값을 비교하라  
        <br>

      - 제어 흐름 변경
        > **JUMP**: 특정 주소로 실행 순서를 옮겨라  
        > **CONDITIONAL JUMP**: 조건에 부합할 때 특정 주소로 실행순서를 옮겨라  
        > **HALT**: 프로그램의 실행을 멈춰라  
        > **CALL**: 되돌아올 주소를 저장한 채 특정 주소로 실행순서를 옮겨라  
        > **RETURN**: CALL을 호출할 때 저장했던 주소로 돌아가라        
        <br>

      - 입출력 변경
        > **READ(INPUT)**: 특정 입출력 장치로부터 데이터를 읽어라   
        > **WRITE(OUTPUT)**: 특정 입출력 장치로 데이터를 써라   
        > **START IO**: 입출력 장치를 시작하라   
        > **TEST IO**: 입출력 장치의 상태를 확인하라
        <br>
  - **오퍼랜드(operand)**   
    - 명령어가 수행할 연산에 사용할 데이터가 저장된 위치(피연산자)    
    - 오퍼랜드가 담기는 영역 operand field(address field)  
    - 숫자, 문자 등을 나타내는 데이터 및 메모리, 레지스터 주소가 올 수 있음
    - 오퍼랜드는 명령어 안에 하나도 없을 수 있고 한 개만 있을 수도 있고, 두 개 또는 세 개 등 여러개 가 올 수 있음
      <br>
      > 오퍼랜드가 하나도 없는 명령어 0-주소 명령어    
      > 오퍼랜드가 하나인 명령어  1-주소 명령어  
      > 오퍼랜드가 두 개인 명령어 2-주소 명령어  
      > 오퍼랜드가 세 개인 명령어 3-주소 명렁어   
  <br>   

  ***
- **주소 지정방식**
  - 명령어의 오퍼랜드 필드에 메모리나 레지스터 주소를 담는 경우가 많아서 오퍼랜드 필드를 주소 필드라고도 함
  - 명령어의 길이 때문에 오퍼랜드 필드에 메모리나 레지스터의 주소를 담음
     > 명령어 n비트, 연산 코드는 m 비트 사용할 수 있는 오퍼랜드의 길이 n-m 비트  
     > 명령어 16bit, 연산 코드 4bit, 2-주소 명령어 오퍼랜드 필드당 6bit = 표현할 수 있는 정보의 수 64개  
     > 명령어 16bit, 연산 코드 4bit, 3-주소 명령어 오퍼랜드 필드당 4bit = 표현할 수 있는 정보의 수 32개
     
  - **유효주소(effective address)**
    - 연산 코드에 사용될 데이터가 저장된 위치, 연산의 대상이 되는 데이터가 저장된 위치 

   - **주소지정 방식(addressing mode)**
      - 오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때 연산에 사용될 데이터 위치를 찾는 방법       
      - **즉시 주소 지정방식(immediate addressing mode)**
        - 가장 간단한 형태의 주소 지정 방식  
        - 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식 
        - 단점: 데이터의 크기가 작아짐
        - 장점: 연산에 사용할 데이터를 메모리, 레지스터로부터 직접 찾는 과정이 없으므로 다른 주소 지정 방식에 비해서 빠름
        <br>   
      - **직접 주소 지정방식(direct addressing mode)**
        - 오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식
        - 오퍼랜드에 표시할 수 있는 데이터의 크기는 즉시 주소 방식 보다 큼
        - 유효 주소를 표현할 수 있는 범위가 연산 코드의 수만큼 줄어듬
        <br>
   
      - **간접 주소 지정방식(indirect addressing mode)**
        - 오퍼랜드 필드에 유효 주소의 주소를 명시하는 방식
        - 두 번의 메모리 접근이 필요하기 때문에 위의 주소 지정 방식 보다 느림
        <br>
  
      - **레지스터 주소 지정방식(register addressing mode)**
        - 직접 주소 방식과 비슷하게 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방식
        - CPU외부에 있는 메모리에 접근하는 것보더 CPU내부에 있는 레지스터에 접근하는 것이 빠름
        - 표현할 수 있는 레지스터 크기에 제한이 있음 
        <br>

      - **레지스터 간접 주소 지정방식(register indirect addressing mode)**
        - 연산에 사용할 데이터를 메모리에 저장하고 그 주소를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방식
        - 유효주소를 찾는 과정이 간접 주소 방식과 비슷하지만, 메모리에 접근하는 횟수가 한번으로 감소
        - 레지스터 간접 주소 지정 방식은 간접 주소 지정 방식보다 빠름
               

***
> 강민철, 『혼자 공부하는 컴퓨터 구조 + 운영체제』, 한빛미디어(2022)  
  
