
## Computer Architecture

### 5장 CPU 성능 향상 기법 

### 5-02 명령어 병렬 처리 기법    
- **명령어 파이프 라인(Instrction pipeline)**
  - 명령어 파이프라인을 이해하기 위해서는 하나의 명령어가 처리되는 전체 과정을 비슷한 시간 간격으로 나누어 보아야 함 
  - 명령어 처리 과정을 클럭 단위로 나누면 일반적으로 아래와 같이 나눌 수 있음 
    > 명령어 인출(Instruction Fecth)   
    > 명령어 해석(Instruction Decode)   
    > 명령어 실행(Execute Instruction)   
    > 결과 저장(Write Back)
     
  - 중요한 점은 단계만 겹치지 않는다면 CPU는 각 단계를 동시에 실행할 수 있음
  - CPU는 명령어를 __'인출'__하는 동안에 다른 명령어를 __'실행'__ 하고 한 명령어가 __'실행'__ 되는 동안에 연산 결과 __'저장'__ 가능
  - 마치 공장 생산 라인과 같은 명령어들을 명령어 파이프라인에 넣고 동시에 처리하는 기법을 __명령어 파이프라이닝(Instruction pipelining)__ 이라고 함
  <br>
- **명령어 파이프라이닝(Instrction pipelining)**
  - 명령어 파이프라인을 사용하지 않고 모든 명령어 순차적으로 처리하는 것 보다 명령어 파이프 라이닝이 효율적임
  - 파이프 라이닝이 높은 성능을 가져 오지만 특정 상황에서 실패하는 경우도 존재 이러한 상황을 __파이프라인 위험(Pipeline hazard)__ 라고 부름
  - 파이프 라인 위험에는 크데 데이터 위험, 제어 위험, 구조적 위험이 존재
  <br>

  - **데이터 위험(Data hazard)**
    - 명령어 간 __'데이터 의존성'__ 에 의해서 발생
    - 모든 명령어를 동시에 처리하는 것을 불가능 어떤 명령어는 이전 명령어를 끝까지 실행해야 실행할 수 있는 경우가 있음
      <br>
      > 명령어 1: R1 <- R2 + R3 // R2 레지스터 값과 R3 레지스터 값을 더한 값을 R1 레지스터에 저장   
      > 명령어 2: R4 <- R1 + R5 // R1 레지스터 값과 R5 레지스터 값을 더한 값을 R4 레지스터에 저장  
    - 명령어 1을 수행해야 명령어 2를 수행 가능 명령어 2는 명령어 1의 데이터에 의존적
    - 데이터 의존적인 두 명령어를 무자적 동시에 실행할려고 하면 파이프라인에 제대로 동작하지 않는 것을 __'데이터 위험'__ 이라고 부름
  <br>

  - **제어 위험(Control hazard)**
    - 제어 위험은 주로 분기 등으로 인한 __'프로그램 카운터의 갑작스런 변화'__ 에 의해 발생
    - 기본적으로 프로그램 카운터는 __'현재 실행 중인 명령어의 다음주소로 갱신'__ 됨
    - 프로그램 실행 흐름이 바뀌어 명령어가 실행되면서 프로그램 카운터의 값에 갑작스러운 변화가 생기면 명령어 파이프라인에 미리 가지고 와서 처리중이었던 명령어들이 쓸모가 없어짐
    - 이를 위하여 사용하는 기술 중 하나가 __분기 예측(Branch prediction)__ 으로 분기 예측은 프로그램이 어디로 분기할지 미리 예측 후 그 주소를 인출하는 방식
  <br>

  - **구조적 위험(Structural hazard)**
    - 명령어들을 겹처 실행하는 과정에서 서로 당른 명령어가 동시에 ALU, 레지스터 등과 같은 CPU 부품을 사용하려고 할 때 발생
    - 구조적 위험은 자원 위험(Resource hazard)라고 부르기도 함  
***
- **슈퍼 스칼라(Supserscalar)**
  - 파이프라이닝은 단일 파이프라인으로 구현이 가능하지만 오늘날 대부분의 CPU에서는 여러 개의 파이프라인을 이용
  - CPU내부에 여러 개의 명령어 파이프라인을 포함한 구조를 슈퍼스칼라라고 부름
  - 슈퍼스칼라 구조로 명령어 처리가 가능한 CPU를 슈퍼스칼라 프로세서 또는 슈퍼 스칼라 CPU라고 함  

***
- **비순차적 명령어 처리(OoOE; Out-of-order execution)**
  - 오늘날 CPU 성능 향상에 크게 기여한 기법으로 대부분의 CPU가 사용하는 기법
  - 이름에서 알 수 있듯이 명령어들을 순차적으로 실행하지 않는 기법으로 명령어의 __'합법적인 새치기'__
  - 명령어 파이프라이닝, 슈퍼 스칼라 기법은 모둔 여려 명령어의 순차적인 처리를 상정한 기법
    
    > M(100) <- 1  
    > M(101) <- 2  
    > M(102) <- M(100) + M(101)  
    > M(150) <- 1  
    > M(151) <- 2  
    > M(152) <- 3  
  - 위의 명령어들 중에서 서로 데이터의 의존성이 전혀 없는 순서를 바꿔 처리 해도 수행 결과이 영향을 미치지 않는 것들이 존재
    > M(100) <- 1    
    > M(101) <- 2  
    > M(150) <- 1  
    > M(151) <- 2  
    > M(152) <- 3  
    > M(102) <- M(100) + M(101)
  - 명령어를 순차적으로 실행하지 않고 순서를 바꿔 실행해도 무방한 명령어를 먼저 실행하여 명령어 파이프라인이 멈추는 것을 방지하는 기법을 비순차적 명령어 처리 기법이라고 함 
***
> 강민철, 『혼자 공부하는 컴퓨터 구조 + 운영체제』, 한빛미디어(2022)  
  
